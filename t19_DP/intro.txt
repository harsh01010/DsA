#include<bits/stdc++.h>
typedef long long int ll;
using namespace std;

/*
    in normal recursion we get overlapping subproblems issue , this make the recursion inefficient.
    to avoid this issue we use DP.
        Dynamic programming is a optimization over plain recursion.
        The idea is to reuse the solution of subproblems when there are overlapping subproblems.
    
    applications:
        bellman ford algo
        floyd warshall algo
        diff utility(LCS)
        search cloased words(edit distance)
        resource algortihm(0-1 kanpsack)
          
    
    Tabulation ---> Bottom up --> base case to required case
    Memoization ---> Top Down  ---> tend to store value of subproblems  in some map/table.

    memoization --> Tabulation --> space optimization 



*/

/*
Fibonacci no.
 0 1 1 2 3 5 8 13 21 ...
 f(n) = f(n-1) + f(n-2  )

 f(n):
  if(n<=1):
    retunr n;
return f(n-1)+f(n-2);

dp[n+1] = -1
f(n):
    if(n<=1):
        return n;
    if(dp[n] != -1}:
        return dp[n];
    dp[n] = f(n-1) + f(n-2);
    return dp[n];


rec to memoization
step 1 --> considering size of subproblems , storing the answers
step 2 --> if subproblem is previously solved
step 3 --> find dp[n]

f(5) --> f(4) --> f(3) --> f(2) --> f(1) --> O(n)
s.c --> O(n) + O(n)(array)

rec to tabulation
dp[n+1]
dp[0] = 0
dp[1] = 1
for(i = 2;i<=n;i++):
    dp[i] = dp[i-1] + dp[i-2];
    
t.c --> O(n)
s.c --> O(n)(array) ,no extra space for recursion stack

tabulation to space optimization:
prev2 = 0 , prev = 1
for(i=2;i<=n;i++)
{
    curr = prev + prev2
    prev2 = prev
    prev = curr
}
t.c --> O(n)
s.c --> o(1)
*/

int main()
{
    



return 0;
}

/*
    1d dp:
    understand dp problem.
    -> count total number of ways 
    -> min , max output

    try all possible ways -> count , best ways --> recursion(all possible way then find best out of them)

    steps to solve:
    1) Try to represent the problem in terms of index.
    2) Do all possible stuffs on that according to the problem statement.
    3)sum of all stuffs -> count all ways , min(of all stuffs) -> find min
*/